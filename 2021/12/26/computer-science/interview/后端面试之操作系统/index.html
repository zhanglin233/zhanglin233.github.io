



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="欢迎来到我的个人博客" href="http://zhanglin233.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="欢迎来到我的个人博客" href="http://zhanglin233.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="欢迎来到我的个人博客" href="http://zhanglin233.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="面试" />


<link rel="canonical" href="http://zhanglin233.github.io/2021/12/26/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">



  <title>
后端面试之操作系统 - 面试 - 计算机科学 |
zhanglin = 欢迎来到我的个人博客</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">后端面试之操作系统
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2021-12-26 13:59:55">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2021-12-26T13:59:55+08:00">2021-12-26</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>19k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>17 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">zhanglin</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclize41wj20zk0m87gk.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/%E9%9D%A2%E8%AF%95/" itemprop="item" rel="index" title="分类于 面试"><span itemprop="name">面试</span></a>
<meta itemprop="position" content="2" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://zhanglin233.github.io/2021/12/26/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="张林">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欢迎来到我的个人博客">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="操作系统基础"><a class="anchor" href="#操作系统基础">#</a> 操作系统基础</h1>
<h2 id="基本特征"><a class="anchor" href="#基本特征">#</a> 基本特征</h2>
<h3 id="并发和并行"><a class="anchor" href="#并发和并行">#</a> 并发和并行</h3>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行是指在同一时刻可以同时运行多个指令</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统</li>
</ul>
<h3 id="共享"><a class="anchor" href="#共享">#</a> 共享</h3>
<ul>
<li>共享是指系统中的资源可以被多个并发进程共同使用</li>
<li>共享的方式有两种：<strong>互斥共享和同时共享</strong></li>
<li>互斥共享的资源称为临界资源；例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问</li>
</ul>
<h3 id="虚拟"><a class="anchor" href="#虚拟">#</a> 虚拟</h3>
<ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体</li>
<li>虚拟技术主要有两种：时（时间）分复用技术和空（空间）分复用技术</li>
<li>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行<strong>页面置换算法</strong>，将该页置换到内存中</li>
</ul>
<h3 id="异步"><a class="anchor" href="#异步">#</a> 异步</h3>
<ul>
<li>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进</li>
</ul>
<h2 id="基本功能"><a class="anchor" href="#基本功能">#</a> 基本功能</h2>
<ul>
<li><strong>进程管理</strong>：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li><strong>内存管理</strong>：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li><strong>文件管理</strong>：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li><strong>设备管理</strong>：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理、虚拟设备等</li>
</ul>
<h2 id="系统调用"><a class="anchor" href="#系统调用">#</a> 系统调用</h2>
<p>如果一个进程在用户态需要使用内核态功能，就进行系统调用从而陷入内核态，之后由操作系统代为完成。</p>
<ul>
<li>工作流程为：
<ul>
<li>用户态程序将一些数据值放在寄存器中，或者使用参数创建一个栈帧 (stack frame), 以此表明需要操作系统提供的服务</li>
<li>用户态程序执行陷阱指令（Trap Instruction，系统调用在 CPU 中的实现）</li>
<li>CPU 切换到内核态，并跳到位于内存指定位置的指令，这些指令是操作系统的一部分，他们具有内存保护，不可被用户态程序访问</li>
<li>这些指令称之为陷阱 (trap) 或者系统调用处理器 (system call handler). 他们会读取程序放入内存的数据参数，并执行程序请求的服务</li>
<li>系统调用完成后，操作系统会重置 CPU 为用户态并返回系统调用的结果</li>
</ul>
</li>
<li>Linux 的系统调用功能主要有：
<ul>
<li>进程控制： <code>fork();exit();wait()</code></li>
<li>进程通信： <code>pipe();shmget();mmap()</code></li>
<li>文件操作： <code>open();read();write()</code></li>
<li>设备操作： <code>ioctl();read();write()</code></li>
<li>信息维护： <code>getpid();alarm();sleep()</code></li>
<li>安全： <code>chmod();umask();chown()</code></li>
</ul>
</li>
</ul>
<h3 id="用户态和内核态"><a class="anchor" href="#用户态和内核态">#</a> 用户态和内核态</h3>
<ul>
<li>内核态：CPU 可以访问内存的所有数据，包括外围设备，CPU 也可以将自己从一个程序切换到另一个程序</li>
<li>用户态：只能受限的访问内存，且不允许访问外围设备，占用 CPU 的能力被剥夺，CPU 资源可以被其他程序获取</li>
<li>切换的三种方式：系统调用（用户进程主动）、中断（被动）、外围设备中断（被动）
<ul>
<li>中断：当 CPU 在用户态下运行时发生一些没有预知的异常，这会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到内核态，比如缺页异常</li>
<li>外围设备中断：当外围设备完成用户请求操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换</li>
</ul>
</li>
<li>用户态切换到内核态的步骤：
<ul>
<li>从当前进程的描述符中提取其内核栈的 <code>ss0</code>  和 <code>esp0</code>  信息</li>
<li>使用 <code>ss0</code>  和 <code>esp0</code>  指向的内核栈将当前进程的 <code>cs,eip,eflags,ss,esp</code>  信息保存起来，这个过程也完成了用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令</li>
<li>将先前由中断向量检索得到的中断处理程序的 <code>cs,eip</code>  信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了</li>
</ul>
</li>
</ul>
<h3 id="中断分类"><a class="anchor" href="#中断分类">#</a> 中断分类</h3>
<ul>
<li><strong>外中断</strong>：由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入 / 输出处理已经完成，处理器能够发送下一个输入 / 输出请求。此外还有时钟中断、控制台中断等</li>
<li><strong>异常</strong>：由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</li>
<li><strong>陷入</strong>：用户程序使用系统调用</li>
</ul>
<h2 id="内核分类"><a class="anchor" href="#内核分类">#</a> 内核分类</h2>
<h3 id="大内核"><a class="anchor" href="#大内核">#</a> 大内核</h3>
<ul>
<li>大内核是将操作系统功能作为一个紧密结合的整体放到内核</li>
<li>由于各模块共享信息，因此有很高的性能</li>
</ul>
<h3 id="微内核"><a class="anchor" href="#微内核">#</a> 微内核</h3>
<ul>
<li>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立</li>
<li>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态</li>
<li>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失</li>
</ul>
<h2 id="软链接和硬链接区别"><a class="anchor" href="#软链接和硬链接区别">#</a> 软链接和硬链接区别</h2>
<ul>
<li>建立软链接和硬链接的语法
<ul>
<li>软链接：ln -s 源文件 目标文件</li>
<li>硬链接：ln 源文件 目标文件</li>
</ul>
</li>
<li>软硬连接的理解
<ul>
<li>软连接类似于快捷方式，指向源文件的地址</li>
<li>硬连接类似于 cp -p 加上同步更新</li>
</ul>
</li>
<li>删除原文件对软硬链接的影响
<ul>
<li>软链接失效</li>
<li>硬链接还可以查看</li>
</ul>
</li>
</ul>
<h2 id="字节序大端小端"><a class="anchor" href="#字节序大端小端">#</a> 字节序（大端小端）</h2>
<ul>
<li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。</li>
<li>小端字节序：低位字节在前，高位字节在后</li>
</ul>
<p>为什么要有大端小段？</p>
<ul>
<li>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。</li>
<li>但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。</li>
<li>一般只有读取外部数据的时候才需要考虑字节序</li>
</ul>
<p>常用系统的大小端</p>
<ul>
<li>
<p>x86 字节序：小端</p>
</li>
<li>
<p>macos：大端</p>
</li>
<li>
<p>网络字节序大端：</p>
<pre><code class="language-c++">//将主机字节序转换为网络字节序
 unit32_t htonl (unit32_t hostlong);
 unit16_t htons (unit16_t hostshort);
 //将网络字节序转换为主机字节序
 unit32_t ntohl (unit32_t netlong);
 unit16_t ntohs (unit16_t netshort);
123456
</code></pre>
</li>
</ul>
<p>如何判断</p>
<ul>
<li>** 判断的思路是：** 确定一个多字节的值（下面使用的是 4 字节的整数），将其写入内存（即赋值给一个变量），然后用指针取其首地址所对应的字节（即低地址的一个字节），判断该字节存放的是高位还是低位，高位说明是 Big endian，低位说明是 Little endian。</li>
</ul>
<h2 id="linux查看端口-进程常用命令"><a class="anchor" href="#linux查看端口-进程常用命令">#</a> linux 查看端口、进程 (常用命令)</h2>
<ul>
<li>netstat -tunlp</li>
<li>ps aux</li>
<li>cat /proc/cpuinfo 显示 CPU info 的信息</li>
<li>df -h 显示已经挂载的分区列表</li>
<li>chmod ugo+rwx directory1 设置目录的所有人 (u)、群组 (g) 以及其他人 (o) 以读（r ）、</li>
<li>tar -cvfj archive.tar.bz2 dir1 创建一个 bzip2 格式的压缩包<br />
 tar -jxvf archive.tar.bz2 解压一个 bzip2 格式的压缩包<br />
 tar -cvfz archive.tar.gz dir1 创建一个 gzip 格式的压缩包<br />
 tar -zxvf archive.tar.gz 解压一个 gzip 格式的压缩包</li>
</ul>
<h1 id="操作系统进程与线程"><a class="anchor" href="#操作系统进程与线程">#</a> 操作系统进程与线程</h1>
<h2 id="进程-线程和协程的概念"><a class="anchor" href="#进程-线程和协程的概念">#</a> 进程、线程和协程的概念</h2>
<ul>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发。</li>
<li>线程是进程内的一个执行实体或执行单元，是 CPU 调度和分派的基本单位，实现进程内部的并发。</li>
<li>区别：
<ul>
<li>调度
<ul>
<li>一个线程只能属于一个进程，而一个进程至少有一个线程。</li>
<li>进程不会相互影响，而线程挂掉一个就会导致整个进程挂掉</li>
</ul>
</li>
<li>资源角度：
<ul>
<li>进程在执行过程中拥有独立的内存单元，而同一进程的多个线程共享进程的内存。每个线程都由自己独立的栈段。</li>
<li>进程是资源分配的最小单位，线程是 CPU 调度的最小单位</li>
</ul>
</li>
<li>系统开销
<ul>
<li>进程的创造销毁切换所花费的系统开销要与远大于线程的开销</li>
</ul>
</li>
<li>进程间通信依靠 IPC，线程间通信直接读取共享数据段</li>
<li>协程和线程区别
<ul>
<li>和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</li>
<li>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="阻塞非阻塞同步异步"><a class="anchor" href="#阻塞非阻塞同步异步">#</a> 阻塞，非阻塞，同步，异步</h2>
<ul>
<li>同步：在发出一个功能调用的时候，在没有得到结果之前，该调用就不返回。（该调用还处于激活状态）</li>
<li>异步：当一个异步调用发出后，调用这并不能立刻得到结果。实际处理调用的部件在完成后通过状态、通知和回调来通知调用者。</li>
<li>阻塞：阻塞调用在调用结果返回之前，线程会被挂起。只有在得到结果之后才会返回。</li>
<li>非阻塞：调用再不能立刻得到结果之前，函数不会阻塞当前进程，而会立刻返回。（recv 接收数据）</li>
</ul>
<h2 id="进程状态转换图"><a class="anchor" href="#进程状态转换图">#</a> 进程状态转换图</h2>
<p><img data-src="https://img-blog.csdnimg.cn/img_convert/522239cb3769cbcb3953658c24d3831f.png" alt="img" /></p>
<p>1）创建状态：进程正在被创建</p>
<p>2）就绪状态：进程被加入到就绪队列中等待 CPU 调度运行</p>
<p>3）执行状态：进程正在被运行</p>
<p>4）等待阻塞状态：进程因为某种原因，比如等待 I/O，等待设备，而暂时不能运行。</p>
<p>5）终止状态：进程运行完毕</p>
<ul>
<li>
<p>交换技术</p>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0 速度比处理机速度慢得多，可能出现全部进程阻塞等待 I/O。</p>
<p>针对以上问题，提出了两种解决方法：</p>
<ul>
<li>1）交换技术：换出一部分进程到外存，腾出内存空间。</li>
<li>2）虚拟存储技术：每个进程只能装入一部分程序和数据。</li>
</ul>
<p>在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。</p>
</li>
<li>
<p>活动阻塞，静止阻塞，活动就绪，静止就绪</p>
<ul>
<li>1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。</li>
<li>2）静止阻塞：进程在外存，同时被某种原因阻塞了。</li>
<li>3）活动就绪：进程在内存，处于就绪状态，只要给 CPU 和调度就可以直接运行。</li>
<li>4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给 CPU 和调度就可以运行。</li>
</ul>
</li>
</ul>
<h3 id="哪些情况进程会由运行转化为阻塞"><a class="anchor" href="#哪些情况进程会由运行转化为阻塞">#</a> 哪些情况进程会由运行转化为阻塞</h3>
<ul>
<li>进程缺少相应 io 资源</li>
<li>访问正在被其他进程访问的临界资源，等待解锁</li>
<li>进程睡眠</li>
</ul>
<h2 id="进程之间的通信方式以及优缺点"><a class="anchor" href="#进程之间的通信方式以及优缺点">#</a> 进程之间的通信方式以及优缺点</h2>
<ul>
<li>
<p>管道（PIPE）</p>
<ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：
<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
<li>使用：
<ol>
<li><strong>int</strong> <strong>mkfifo</strong>(<strong>const</strong> <strong>char</strong> *path, <strong>mode_t</strong> mode);</li>
<li><strong>int</strong> <strong>mkfifoat</strong>(<strong>int</strong> fd, <strong>const</strong> <strong>char</strong> *path, <strong>mode_t</strong> mode);</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
<ul>
<li>优点：简单方便</li>
<li>缺点：
<ol>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
<li>使用：
<ol>
<li>父进程创建一个管道，创建一个数组作为索引。（int pipe（int fd [2]））</li>
<li>fork 一个子进程，子进程会复制父进程的管道文件。父子进程根据需要各自关闭读写端。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问</p>
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
<li>使用（SIGHUP）子进程监视父进程是否存在，接收父进程死亡的信号</li>
<li>只有当管道所有的读端都被关闭时，才会产生 SIGPIPE</li>
</ul>
</li>
<li>
<p>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</p>
</li>
<li>
<p>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识</p>
<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>
<p>共享内存（Shared Memory）：共享内存就是允许两个或多个进程共享一定的存储区。就如同 malloc () 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为数据不需要在客户机和服务器端之间复制，数据直接写到内存，不用若干次数据拷贝，所以这是最快的一种 IPC。</p>
<p>注：共享内存没有任何的同步与互斥机制，所以要使用信号量来实现对共享内存的存取的同步。</p>
<ul>
<li>
<p>优点：无须复制，快捷，信息量大</p>
</li>
<li>
<p>缺点：</p>
<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
<li>
<pre><code>int` `shmget(key_t key, ``size_t` `size, ``int` `shmflg);
1
</code></pre>
<p>(1) 第一个参数 key 是长整型（唯一非零），系统建立 IPC 通讯 （ 消息队列、 信号量和 共享内存） 时必须指定一个 ID 值。通常情况下，该 id 值通过 ftok 函数得到，由内核变成标识符，要想让两个进程看到同一个信号集，只需设置 key 值不变就可以。</p>
<p>(2) 第二个参数 size 指定共享内存的大小，它的值一般为一页大小的整数倍（未到一页，操作系统向上对齐到一页，但是用户实际能使用只有自己所申请的大小）。</p>
<p>(3) 第三个参数 shmflg 是一组标志，创建一个新的共享内存，将 shmflg 设置了 IPC_CREAT 标志后，共享内存存在就打开。而 IPC_CREAT | IPC_EXCL 则可以创建一个新的，唯一的共享内存，如果共享内存已存在，返回一个错误。一般我们会还或上一个文件权限</p>
</li>
</ul>
</li>
<li>
<p>套接字（Socket）：可用于不同计算机间的进程通信</p>
<ul>
<li>优点：
<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密，数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h2 id="进程间的调度算法"><a class="anchor" href="#进程间的调度算法">#</a> 进程间的调度算法</h2>
<ul>
<li>批处理系统：先来先服务、短作业优先、最短剩余时间优先</li>
<li>交互式系统：时间片轮转、优先级调度，多级反馈队列</li>
</ul>
<h2 id="线程之间的通信方式"><a class="anchor" href="#线程之间的通信方式">#</a> 线程之间的通信方式</h2>
<ul>
<li>锁机制：包括互斥锁 / 量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
<ul>
<li>互斥锁 / 量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。（shared_mutex）
<ul>
<li>shared_mutex 比一般的 mutex 多了函数 lock_shared ()/unlock_shared (), 允许多个（读者）线程同时加锁、解锁，而 shared_lock 则相当于共享版的 lock_guard。</li>
<li>对 shared_mutex 使用 lock_guard 或者 unique_lock 即达到了写着独占的目的。</li>
</ul>
</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
<ul>
<li>自旋锁主要适用于被持有时间短，线程不希望在重新调度上花过多时间的情况。实际上许多其他类型的锁在底层使用了自旋锁实现，例如多数互斥锁在试图获取锁的时候会先自旋一小段时间，然后才会休眠。如果在持锁时间很长的场景下使用自旋锁，则会导致 CPU 在这个线程的时间片用尽之前一直消耗在无意义的忙等上，造成计算资源的浪费。</li>
</ul>
</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
<ul>
<li>condition</li>
</ul>
</li>
</ul>
</li>
<li>信号量机制 (Semaphore)
<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制 (Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<h2 id="进程-线程之间私有和共享的资源"><a class="anchor" href="#进程-线程之间私有和共享的资源">#</a> 进程、线程之间私有和共享的资源</h2>
<h3 id="进程之间私有和共享的资源"><a class="anchor" href="#进程之间私有和共享的资源">#</a> 进程之间私有和共享的资源</h3>
<ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h3 id="线程之间私有和共享的资源"><a class="anchor" href="#线程之间私有和共享的资源">#</a> 线程之间私有和共享的资源</h3>
<ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h2 id="多进程和多线程对比"><a class="anchor" href="#多进程和多线程对比">#</a> 多进程和多线程对比</h2>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h3 id="多进程和多线程优劣"><a class="anchor" href="#多进程和多线程优劣">#</a> 多进程和多线程优劣</h3>
<table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<h3 id="多进程和多线程选择"><a class="anchor" href="#多进程和多线程选择">#</a> 多进程和多线程选择</h3>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<h2 id="fork函数pid_t-fork-void"><a class="anchor" href="#fork函数pid_t-fork-void">#</a> fork 函数（pid_t fork (void);）</h2>
<ul>
<li>
<p>调用后执行的功能</p>
<ul>
<li>向系统申请一个新 PID</li>
<li>创建子进程，复制父进程的 PCB，获得父进程的数据空间、堆、栈等资源的副本</li>
<li>在父进程中返回子进程的 PID，在子进程中返回 0</li>
<li>执行完以上动作后，父进程和子进程便开始并发执行了。</li>
<li>fork () 返回值</li>
<li>父进程中的 fork () 结束后返回子进程的 pid</li>
<li>子进程中的 fork () 结束后返回 0</li>
<li>错误返回负值</li>
</ul>
</li>
<li>
<p>写时拷贝</p>
<ul>
<li>如果每一次 fork () 都要拷贝很浪费内存，linux 中就在 fork () 后让父子进程共享内存，当进行写操作时再进行拷贝</li>
</ul>
</li>
<li>
<p>fork 和 vfork 的区别：</p>
<p>\1. fork () 的子进程拷贝父进程的数据段和代码段；vfork () 的子进程与父进程共享数据段</p>
<p>\2. fork () 的父子进程的执行次序不确定；vfork () 保证子进程先运行，在调用 exec 或 exit 之前与父进程数据是共享的，在它调用 exec 或 exit 之后父进程才可能被调度运行。</p>
<p>\3. vfork ( ) 保证子进程先运行，在它调用 exec 或 exit 之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
<p>4. 当需要改变共享数据段中变量的值，则拷贝父进程。</p>
</li>
<li>
<p>fork 实例</p>
</li>
</ul>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token function">signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before fork pid:%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> abc <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"tile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        abc<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child:%d,parent: %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"abc:%d"</span><span class="token punctuation">,</span> abc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        abc<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"parent:pid:%d \n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"abc:%d \n"</span><span class="token punctuation">,</span> abc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>		<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fork after...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token number">123456789101112131415161718192021222324</span></pre></td></tr></table></figure><h3 id=""><a class="anchor" href="#">#</a> </h3>
<h2 id="线程池原理"><a class="anchor" href="#线程池原理">#</a> 线程池原理</h2>
<ul>
<li>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力，假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。</li>
<li>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</li>
<li>一个线程池包括以下四个基本组成部分：<br />
1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；<br />
2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；<br />
3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；<br />
4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>
<li>线程池技术正是关注如何缩短或调整 T1,T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有 T1，T3 的开销了。<br />
线程池不仅调整 T1,T3 产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：<br />
假设一个服务器一天要处理 50000 个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为 50000。一般线程池大小是远小于 50000。所以利用线程池的服务器程序不会为了创建 50000 而在处理请求时浪费时间，从而提高效率。</li>
<li>怎么实现线程池
<ul>
<li>1. 设置一个生产者消费者队列，作为临界资源</li>
<li>2. 初始化 n 个线程，并让其运行起来，加锁去队列取任务运行</li>
<li>3. 当任务队列为空的时候，所有线程阻塞</li>
<li>4. 当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li>
</ul>
</li>
</ul>
<h3 id="正常进程-僵尸进程和孤儿进程"><a class="anchor" href="#正常进程-僵尸进程和孤儿进程">#</a> 正常进程、僵尸进程和孤儿进程</h3>
<ul>
<li>
<p>正常进程</p>
<ul>
<li>
<p>正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用 wait () 或者 waitpid () 系统调用取得子进程的终止状态。</p>
<p>unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过 wait /waitpid 来取时才释放。保存信息包括：</p>
<p>1 进程号 the process ID</p>
<p>2 退出状态 the termination status of the process</p>
<p>3 运行时间 the amount of CPU time taken by the process 等</p>
</li>
</ul>
</li>
<li>
<p>孤儿进程</p>
<ul>
<li>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程号为 1) 所收养，并由 init 进程对它们完成状态收集工作。</li>
</ul>
</li>
<li>
<p>僵尸进程</p>
<ul>
<li>
<p>一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<p>僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。</p>
<p>如果子进程在 exit () 之后，父进程没有来得及处理，这时用 ps 命令就能看到子进程的状态是 “Z”。如果父进程能及时 处理，可能用 ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。</p>
<p>如果父进程在子进程结束之前退出，则子进程将由 init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。</p>
</li>
</ul>
</li>
<li>
<p>危害：</p>
<ul>
<li>如果进程不调用 wait /waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</li>
</ul>
</li>
<li>
<p>外部消灭：</p>
<ul>
<li>通过 kill 发送 SIGTERM 或者 SIGKILL 信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管，init 进程会 wait () 这些孤儿进程，释放它们占用的系统进程表中的资源</li>
</ul>
</li>
<li>
<p>内部解决：</p>
<ul>
<li>1、子进程退出时向父进程发送 SIGCHILD 信号，父进程处理 SIGCHILD 信号。在信号处理函数中调用 wait 进行处理僵尸进程。</li>
<li>2、fork 两次，原理是将子进程成为孤儿进程，从而其的父进程变为 init 进程，通过 init 进程可以处理僵尸进程。</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h2>
<h3 id="原因"><a class="anchor" href="#原因">#</a> 原因</h3>
<ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<h3 id="产生条件"><a class="anchor" href="#产生条件">#</a> 产生条件</h3>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li>环路</li>
</ul>
<h3 id="编码时解决死锁"><a class="anchor" href="#编码时解决死锁">#</a> 编码时解决死锁</h3>
<ul>
<li>
<p>死锁的一般解决方案：</p>
<ul>
<li>只要保证两个互斥量上锁的顺序一致，就不会死锁</li>
<li>std::lock () 函数模板
<ul>
<li>能力：一次锁住两个或者两个以上的互斥量（至少两个，多个不行，1 个不行）；</li>
<li>不存在因为锁头的顺序问题导致的死锁风险问题</li>
<li>原理，std::lock ()：要么两个互斥量都缩住，要么两个互斥量都没锁柱，一旦有一个没锁住就会解锁另一个已经锁住的互斥量。</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">		std::lock(my_mutex1, my_mutex2);
// 		my_mutex2.lock();
// 		my_mutex1.lock();
123
</code></pre>
</li>
<li>
<p>std::lock_guard 的 std::adopt_lock 参数</p>
<ul>
<li>adopt_lock 是一个结构体对象，起标记作用，标记已经此锁已经 lock</li>
</ul>
<pre><code class="language-c++">std::lock(my_mutex1, my_mutex2);
std::lock_guard&lt;std::mutex&gt;sbgurad1(my_mutex1,std::adopt_lock); //用一个大括号包含需要加锁的代码段，提前结束lock_guard的生命周期
std::lock_guard&lt;std::mutex&gt;sbgurad2(my_mutex2,std::adopt_lock); 
123
</code></pre>
</li>
</ul>
<h3 id="处理方法"><a class="anchor" href="#处理方法">#</a> 处理方法</h3>
<ul>
<li>
<p><strong>鸵鸟策略</strong>：当作没有发生死锁</p>
<ul>
<li>因为解决死锁的代价很大，因此这种方案可以获得更高的性能；当发生死锁时不会对用户造成很大影响，或者发生死锁的概率很低，可以采用鸵鸟策略；大多数操作系统，包括 <code>unix</code> ， <code>linux</code>  和 <code>windows</code>  处理死锁问题的办法仅仅是忽略他</li>
</ul>
</li>
<li>
<p><strong>死锁检测和死锁恢复</strong>：不试图阻止死锁，而是检测到死锁发生时，采取措施进行恢复</p>
<ul>
<li>每种类型一个资源的死锁检测通过检测有向图是否存在环来实现。</li>
<li>每种类型多个资源的死锁检测</li>
<li>死锁恢复：利用抢占恢复，利用回滚恢复，通过杀死进程恢复</li>
</ul>
</li>
<li>
<p><strong>死锁预防</strong>：在程序运行之前预防死锁</p>
<ul>
<li>破坏互斥条件</li>
<li>破坏占有和等待条件：一种方式是规定所有进程在开始执行前请求所需的全部资源</li>
<li>破坏不可抢占条件</li>
<li>破坏环路等待：给资源统一编号，进程只能按照编号顺序来请求资源</li>
</ul>
</li>
<li>
<p><strong>死锁避免</strong>：在运行时避免发生死锁</p>
<ul>
<li>
<p><strong>安全状态</strong>：是指如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每个进程运行完毕，则称该状态是安全的</p>
<p><img data-src="https://blog.csdn.net/weixin_42699130/article//assets/post/2020-02-15/safestate.png" alt="img" /></p>
</li>
<li>
<p>上图中，图 a 的第二列 Has 表示进程已经拥有的资源数，第三列 Max 表示进程总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始，先让 B 拥有所需的有时又资源，运行结束后释放 B，此时 free 变为 5；以同样方式运行 C 和 A，使得所有进程都能成功运行，因此可以<strong>称 A 的状态是安全</strong>的。</p>
</li>
<li>
<p><strong>银行家算法</strong>：判断对请求的满足是否会进入不安全状态，如果是就拒绝请求；否则予以分配</p>
</li>
</ul>
</li>
</ul>
<h2 id="linux的4种锁机制"><a class="anchor" href="#linux的4种锁机制">#</a> Linux 的 4 种锁机制：</h2>
<ul>
<li>互斥锁：互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</li>
<li>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</li>
<li>自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费 CPU 资源。</li>
<li>RCU：即 read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据 update 成新的数据。使用 RCU 时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。</li>
</ul>
<h2 id="经典同步问题"><a class="anchor" href="#经典同步问题">#</a> 经典同步问题</h2>
<h3 id="哲学家进餐问题"><a class="anchor" href="#哲学家进餐问题">#</a> 哲学家进餐问题</h3>
<p>多个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<pre><code class="language-c++">#define N 5
void philosopher(int i) &#123;
    while(TRUE) &#123;
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    &#125;
&#125;
1234567891011
</code></pre>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<pre><code class="language-c++">#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) &#123;
    while(TRUE) &#123;
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    &#125;
&#125;

void take_two(int i) &#123;
    down(&amp;mutex);
    state[i] = HUNGRY;
    check(i);
    up(&amp;mutex);
    down(&amp;s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
&#125;

void put_two(i) &#123;
    down(&amp;mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&amp;mutex);
&#125;

void eat(int i) &#123;
    down(&amp;mutex);
    state[i] = EATING;
    up(&amp;mutex);
&#125;

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行
void check(i) &#123;         
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;
        state[i] = EATING;
        up(&amp;s[i]);
    &#125;
&#125;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849
</code></pre>
<h3 id="读者-写者问题"><a class="anchor" href="#读者-写者问题">#</a> 读者 - 写者问题</h3>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code class="language-c++">typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() &#123;
    while(TRUE) &#123;
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);
        read();
        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);
        up(&amp;count_mutex);
    &#125;
&#125;

void writer() &#123;
    while(TRUE) &#123;
        down(&amp;data_mutex);
        write();
        up(&amp;data_mutex);
    &#125;
&#125;
1234567891011121314151617181920212223242526
</code></pre>
<h2 id="进程线程常见面试题"><a class="anchor" href="#进程线程常见面试题">#</a> 进程线程常见面试题</h2>
<h3 id="设计一下如何采用单线程的方式处理高并发"><a class="anchor" href="#设计一下如何采用单线程的方式处理高并发">#</a> 设计一下如何采用单线程的方式处理高并发</h3>
<ul>
<li>在单线程模型中，可以采用 I/O 复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</li>
</ul>
<h3 id="如何设计server使得能够接收多个客户端的请求"><a class="anchor" href="#如何设计server使得能够接收多个客户端的请求">#</a> 如何设计 server，使得能够接收多个客户端的请求</h3>
<ul>
<li>单线程 + io 复用</li>
<li>线程池</li>
<li>多线程</li>
</ul>
<h3 id="死循环来连接时新建线程的方法效率有点低怎么改进"><a class="anchor" href="#死循环来连接时新建线程的方法效率有点低怎么改进">#</a> 死循环 + 来连接时新建线程的方法效率有点低，怎么改进？</h3>
<ul>
<li>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。</li>
<li>改进死循环：使用 select epoll 这样的技术</li>
</ul>
<h3 id="怎么唤醒被阻塞的socket线程"><a class="anchor" href="#怎么唤醒被阻塞的socket线程">#</a> 怎么唤醒被阻塞的 socket 线程？</h3>
<p>当 socket 接受到数据，中断程序调用回调函数唤醒线程</p>
<h3 id="有了进程为什么还要有线程"><a class="anchor" href="#有了进程为什么还要有线程">#</a> 有了进程，为什么还要有线程？</h3>
<ul>
<li>
<p>线程产生的原因：如果没有线程，那么一个进程在同一时间只能干一件事情。如果进程在执行过程中因为缺少资源而被阻塞，即使有些任务不需要当前缺少的资源，整个进程也会被挂起。</p>
</li>
<li>
<p>线程的优势</p>
<ul>
<li>从资源上来讲，线程是一种非常 &quot;节俭&quot; 的多任务操作方式。在 linux 系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种 &quot;昂贵&quot; 的多任务工作方式。而线程可以共享进程的内存空间。</li>
<li>从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的 30 倍左右。</li>
<li>从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。</li>
</ul>
</li>
<li>
<p>多线程程序作为一种多任务、并发的工作方式，还有如下优点：</p>
<p>1、使多 CPU 系统更加有效。操作系统会保证当线程数不大于 CPU 数目时，不同的线程运行于不同的 CPU 上。</p>
<p>2、改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</p>
</li>
</ul>
<h3 id="单核机器上写多线程程序是否需要考虑加锁为什么"><a class="anchor" href="#单核机器上写多线程程序是否需要考虑加锁为什么">#</a> 单核机器上写多线程程序，是否需要考虑加锁，为什么？</h3>
<ul>
<li>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。</li>
</ul>
<h1 id="操作系统内存管理"><a class="anchor" href="#操作系统内存管理">#</a> 操作系统内存管理</h1>
<h2 id="虚拟内存"><a class="anchor" href="#虚拟内存">#</a> 虚拟内存</h2>
<ul>
<li>目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</li>
<li>为了更好的管理内存，系统将内存抽象成地址空间。</li>
<li>每个程序拥有自己的地址空间，这个地址空间被分为多个块，每一块为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都在物理内存中。</li>
<li>当引用到不再物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的命令</li>
<li>虚拟内存允许内存不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行。16 位地址可以映射 64KB 地址，32 位可以映射 4GB 地址。</li>
</ul>
<p>[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-MKdpIXFh-1602222903766)(C:\Users\free\AppData\Roaming\Typora\typora-user-images\image-20200816131820778.png)]</p>
<h3 id="分页系统地址映射"><a class="anchor" href="#分页系统地址映射">#</a> 分页系统地址映射</h3>
<p>内存管理单元（ <code>Memory Management Unit, MMU</code> ）管理着地址空间和物理内存的转换，其中的页表（ <code>Page table</code> ）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。即（存储页面号 + 页内偏移量）</p>
<p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（ <code>0010 0000 0000 0100</code> ），前 4 位是存储页面号 2，读取表项内容为（ <code>110 1</code> ），页表项最后一位表示是否存在于内存中，1 表示存在，0 表示不存在。后 12 位存储偏移量。这个页对应的页框的地址为 （ <code>110 0000 0000 0100</code> ）。</p>
<p>[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-cwfAMftM-1602222903769)(C:\Users\free\AppData\Roaming\Typora\typora-user-images\image-20200816131902810.png)]</p>
<h3 id="页面置换算法"><a class="anchor" href="#页面置换算法">#</a> 页面置换算法</h3>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生<strong>缺页中断</strong>从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h4 id="最佳optimal-replacement-algorithm-opt"><a class="anchor" href="#最佳optimal-replacement-algorithm-opt">#</a> 最佳（Optimal replacement algorithm, OPT）</h4>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p>
<h4 id="最近最久未使用least-recently-usedlru"><a class="anchor" href="#最近最久未使用least-recently-usedlru">#</a> 最近最久未使用（Least Recently Used，LRU）</h4>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>为了实现 LRU，需要在内存中维护一个所有页面的链表。<strong>当一个页面被访问时，将这个页面移到链表表头</strong>。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>因为每次<strong>访问都需要更新链表</strong>，因此这种方式实现的 LRU 代价很高。</p>
<h4 id="最近未使用not-recently-usednru"><a class="anchor" href="#最近未使用not-recently-usednru">#</a> 最近未使用（Not Recently Used，NRU）</h4>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的<strong>脏页面（R=0，M=1）</strong>，而不是被频繁使用的<strong>干净页面（R=1，M=0）</strong></p>
<h4 id="先入先出first-in-first-out-fifo"><a class="anchor" href="#先入先出first-in-first-out-fifo">#</a> 先入先出（First In First Out, FIFO）</h4>
<p>选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<h4 id="第二次机会算法"><a class="anchor" href="#第二次机会算法">#</a> 第二次机会算法</h4>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<ul>
<li>当页面被访问 (读或写) 时设置该页面的 R 位为 1。</li>
<li>需要替换的时候，检查最老页面的 R 位。</li>
<li>如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；</li>
<li>如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</li>
</ul>
<h4 id="时钟clock"><a class="anchor" href="#时钟clock">#</a> 时钟（Clock）</h4>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p>
<h2 id="分段和分页"><a class="anchor" href="#分段和分页">#</a> 分段和分页</h2>
<ul>
<li>分段通俗解释：linux 中就把一个程序分成代码段，数据段和堆栈段等。</li>
<li>分页通俗解释：将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱</li>
<li>然后我们就可以通过段号，页号和页内偏移找到程序的地址</li>
</ul>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p>分段的做法是把每个表分成段，<strong>一个段构成一个独立的地址空间</strong>。每个段的长度可以不同，并且可以动态增长。</p>
<h2 id="段页式"><a class="anchor" href="#段页式">#</a> 段页式</h2>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h3 id="分页和分段的比较"><a class="anchor" href="#分页和分段的比较">#</a> 分页和分段的比较</h3>
<ul>
<li>对程序员：分页透明，分段需要程序员显式划分每个段</li>
<li>地址空间维度：分页地址是一维的，分段地址是二维（段名 + 段内地址）的</li>
<li>大小是否可以改变：分页不可变，分段可变</li>
<li>出现的原因：分页主要用于虚拟内存，从而获得更大的地址空间；分段是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</li>
</ul>
<h1 id="操作系统linux"><a class="anchor" href="#操作系统linux">#</a> 操作系统 linux</h1>
<h2 id="linux文件系统"><a class="anchor" href="#linux文件系统">#</a> Linux 文件系统</h2>
<ul>
<li><code>superblock</code> ：记录文件系统的整体信息，包括 inode 和 block 的总量，使用量和剩余量，以及文件系统的格式及相关信息等；</li>
<li><code>block bitmap</code> ：记录 block 是否被使用的位图</li>
<li><code>inode</code> ：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li><code>block</code> ：记录文件的内容，文件太大时，会占用多个 block</li>
</ul>
<p>[外链图片转存失败，源站可能有防盗链机制，建议将图片保存下来直接上传 (img-QwXtsh0d-1602222903774)(C:/Users/free/Desktop/ 面试 /interviewmd/assets/post/2018-04-02/BSD_disk.png)]</p>
<p><strong>文件系统如何找到文件？</strong></p>
<ul>
<li>根据文件名，通过 Dictionary 的对应关系，找到文件对用的 inode number</li>
<li>再根据 inode number 读取到文件的 inode table</li>
<li>根据 inode table 中的 pointer 读取到相应的 blocks</li>
</ul>
<h2 id="linux文件是怎么存储的"><a class="anchor" href="#linux文件是怎么存储的">#</a> Linux 文件是怎么存储的</h2>
<p>一个文件由目录项，inode 和数据块组成。</p>
<ul>
<li>目录项：包括文件名和 inode 节点号</li>
<li>inode：又称为文件索引节点，包含文件的基础信息以及数据块的指针</li>
<li>数据块：包含文件的具体内容</li>
</ul>
<p>硬盘的最小存储单元为” 扇区 sector“，每个扇区存储 512 字节（0.5KB），操作系统读取硬盘时，一次性连续读取多个扇区，即一个” 块 block“。每个块最常见的大小为 4K，即 8 个扇区</p>
<p>inode 存储文件的元信息，以及文件数据 block 的位置。</p>
<ul>
<li>
<p>一个文件可以被存储在一个或者多个 block 中</p>
</li>
<li>
<p>每个文件都会并且只会占用一个 inode，inode 可以指向该文件所在的 block</p>
</li>
<li>
<p>想读取该文件，需要通过</p>
<p>目录项</p>
<p>的文件名来指向正确的 inode 号码才能读取</p>
<ul>
<li>** 目录项：** 当新建一个目录时，文件系统会分配一个 inode 和至少一个 block 给该目录。其中 inode 记录目录的相关权限和属性，并记录分配到的那块 block 目录。而 block 则是记录在这个目录下的文件名和其对应的 inode 号码数据，这就是数据项</li>
</ul>
</li>
</ul>
<h2 id="文件处理命令待学习"><a class="anchor" href="#文件处理命令待学习">#</a> 文件处理命令（待学习）</h2>
<h3 id="grep"><a class="anchor" href="#grep">#</a> grep</h3>
<p>文本过滤器，可以使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<h3 id="sed"><a class="anchor" href="#sed">#</a> sed</h3>
<p>流编辑器，默认只处理模式空间，不处理原数据。处理时，把当前处理的行存储在临时缓冲区，称为 “模式空间”（pattern space），接着用 sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送到屏幕，接着处理下一行，直到文件末尾。文件内容并没有改变，除非使用重定向存储输出。</p>
<h3 id="awk"><a class="anchor" href="#awk">#</a> awk</h3>
<p>文本分析工具，相对于 grep 的查找，sed 的编辑，awk 在数据分析和生成数据显得尤为强大。awk 把文件逐行读入，以空格为默认分隔符将每行切片，切开的部分进行分析处理。</p>
<h2 id="文件的三种时间"><a class="anchor" href="#文件的三种时间">#</a> 文件的三种时间</h2>
<ul>
<li><code>mtime(Modification)</code> ：更改文件内容时会更新这个时间</li>
<li><code>atime(Access)</code> ：读取文件，比如使用 less，more 读取时会更新这个时间</li>
<li><code>ctime(Change)</code> ：在修改权限，写入文件、更改所有者、权限或者链接设置时随着 inode 的内容更改而更改，即文件状态最后一次被更改的时间</li>
</ul>
<h2 id="shell脚本"><a class="anchor" href="#shell脚本">#</a> shell 脚本</h2>
<p>待学习</p>
<h2 id="硬链接和软连接"><a class="anchor" href="#硬链接和软连接">#</a> 硬链接和软连接</h2>
<h3 id="硬链接"><a class="anchor" href="#硬链接">#</a> 硬链接</h3>
<pre><code>ln [sourceFile] [linkName]
</code></pre>
<p>A 是 B 的硬链接，则 A 的目录项中的 inode 节点号于 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，A 和 B 对于系统来说是完全平等的。</p>
<p>如果删除了其中一个，对另一个没有影响。每增加一个硬链接的文件名，inode 节点上的链接数增加 1，每删除一个就减 1，直到为 0，inode 节点和对应的 block 被回收。</p>
<p>** 注意：** 文件和文件名是两个不同的东西， <code>rm A</code>  删除的只是 A 这个文件名，但是其对应的数据块（文件）并没有被删除，文件只有在 inode 节点链接数减少为 0 时才会被删除。</p>
<h3 id="软连接"><a class="anchor" href="#软连接">#</a> 软连接</h3>
<pre><code>ln -s [sourceFile] [linkName]
</code></pre>
<p>A 是 B 的软连接，A 的目录项中的 inode 节点号和 B 的目录项中的 inode 节点号不同，A 和 B 指向不同的 inode，继而指向不同的数据库。但是 A 的数据块中存储的是 B 的路径名（可以根据这个路径名找到 B 的目录项）。A 和 B 之间是 “主从” 关系，如果 B 被删除了，A 依然存在，但指向的是一个无效链接。</p>
<h3 id="区别"><a class="anchor" href="#区别">#</a> 区别</h3>
<h4 id="硬链接-2"><a class="anchor" href="#硬链接-2">#</a> 硬链接</h4>
<ul>
<li>不能对目录创建硬链接，原因有几种，最重要的是：文件系统不能存在链接环（目录创建时的 &quot;…&quot; 除外，这个系统可以识别出来）, 存在环的后果会导致例如文件遍历等操作的混乱 (du，pwd 等命令的运作原理就是基于文件硬链接，顺便一提，ls -l 结果的第二列也是文件的硬链接数，即 inode 节点的链接数)</li>
<li>不能对不同的文件系统创建硬链接，即两个文件名要在相同的文件系统下。</li>
<li>不能对不存在的文件创建硬链接，由原理即可知原因。</li>
</ul>
<h4 id="软连接-2"><a class="anchor" href="#软连接-2">#</a> 软连接</h4>
<ul>
<li>可以对目录创建软连接，遍历操作会忽略目录的软连接。</li>
<li>可以跨文件系统</li>
<li>可以对不存在的文件创建软连接，因为保存的只是一个字符串</li>
</ul>

      <div class="tags">
          <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"><i class="ic i-tag"></i> 面试</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2022-01-12 14:32:23" itemprop="dateModified" datetime="2022-01-12T14:32:23+08:00">2022-01-12</time>
  </span>
  <span id="2021/12/26/computer-science/interview/后端面试之操作系统/" class="item leancloud_visitors" data-flag-title="后端面试之操作系统" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="张林 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="张林 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="张林 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>张林 <i class="ic i-at"><em>@</em></i>欢迎来到我的个人博客
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://zhanglin233.github.io/2021/12/26/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="后端面试之操作系统">http://zhanglin233.github.io/2021/12/26/computer-science/interview/后端面试之操作系统/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2021/12/25/computer-science/interview/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx6phq6j20zk0m8e36.jpg" title="后端面试常问问题">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 面试</span>
  <h3>后端面试常问问题</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/01/06/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfw2t96j20zk0m8x6p.jpg" title="后端面试之数据库">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 面试</span>
  <h3>后端面试之数据库</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text"> 操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text"> 基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 虚拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text"> 基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text"> 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 用户态和内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 中断分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text"> 内核分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 大内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 微内核</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text"> 软链接和硬链接区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="toc-number">1.6.</span> <span class="toc-text"> 字节序（大端小端）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3-%E8%BF%9B%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.</span> <span class="toc-text"> linux 查看端口、进程 (常用命令)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 操作系统进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程、线程和协程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text"> 阻塞，非阻塞，同步，异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程状态转换图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E8%BF%9B%E7%A8%8B%E4%BC%9A%E7%94%B1%E8%BF%90%E8%A1%8C%E8%BD%AC%E5%8C%96%E4%B8%BA%E9%98%BB%E5%A1%9E"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 哪些情况进程会由运行转化为阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text"> 进程之间的通信方式以及优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text"> 进程间的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text"> 线程之间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">2.7.</span> <span class="toc-text"> 进程、线程之间私有和共享的资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 进程之间私有和共享的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%A7%81%E6%9C%89%E5%92%8C%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 线程之间私有和共享的资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">2.8.</span> <span class="toc-text"> 多进程和多线程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8A%A3"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 多进程和多线程优劣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%89%E6%8B%A9"><span class="toc-number">2.8.2.</span> <span class="toc-text"> 多进程和多线程选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0pid_t-fork-void"><span class="toc-number">2.9.</span> <span class="toc-text"> fork 函数（pid_t fork (void);）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.9.1.</span> <span class="toc-text"> </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-number">2.10.</span> <span class="toc-text"> 线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E8%BF%9B%E7%A8%8B-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.10.1.</span> <span class="toc-text"> 正常进程、僵尸进程和孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">2.11.</span> <span class="toc-text"> 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.11.1.</span> <span class="toc-text"> 原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.11.2.</span> <span class="toc-text"> 产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%97%B6%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="toc-number">2.11.3.</span> <span class="toc-text"> 编码时解决死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">2.11.4.</span> <span class="toc-text"> 处理方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E7%9A%844%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">2.12.</span> <span class="toc-text"> Linux 的 4 种锁机制：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.13.</span> <span class="toc-text"> 经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.13.1.</span> <span class="toc-text"> 哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.13.2.</span> <span class="toc-text"> 读者 - 写者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.14.</span> <span class="toc-text"> 进程线程常见面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">2.14.1.</span> <span class="toc-text"> 设计一下如何采用单线程的方式处理高并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1server%E4%BD%BF%E5%BE%97%E8%83%BD%E5%A4%9F%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">2.14.2.</span> <span class="toc-text"> 如何设计 server，使得能够接收多个客户端的请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87%E6%9C%89%E7%82%B9%E4%BD%8E%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B"><span class="toc-number">2.14.3.</span> <span class="toc-text"> 死循环 + 来连接时新建线程的方法效率有点低，怎么改进？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%94%A4%E9%86%92%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%9A%84socket%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.14.4.</span> <span class="toc-text"> 怎么唤醒被阻塞的 socket 线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BA%86%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.14.5.</span> <span class="toc-text"> 有了进程，为什么还要有线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.6.</span> <span class="toc-text"> 单核机器上写多线程程序，是否需要考虑加锁，为什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text"> 操作系统内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text"> 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 分页系统地址映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3optimal-replacement-algorithm-opt"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 最佳（Optimal replacement algorithm, OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8least-recently-usedlru"><span class="toc-number">3.1.2.2.</span> <span class="toc-text"> 最近最久未使用（Least Recently Used，LRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8not-recently-usednru"><span class="toc-number">3.1.2.3.</span> <span class="toc-text"> 最近未使用（Not Recently Used，NRU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%85%A5%E5%85%88%E5%87%BAfirst-in-first-out-fifo"><span class="toc-number">3.1.2.4.</span> <span class="toc-text"> 先入先出（First In First Out, FIFO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.5.</span> <span class="toc-text"> 第二次机会算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9Fclock"><span class="toc-number">3.1.2.6.</span> <span class="toc-text"> 时钟（Clock）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5"><span class="toc-number">3.2.</span> <span class="toc-text"> 分段和分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text"> 段页式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 分页和分段的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Flinux"><span class="toc-number">4.</span> <span class="toc-text"> 操作系统 linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.</span> <span class="toc-text"> Linux 文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E6%96%87%E4%BB%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">4.2.</span> <span class="toc-text"> Linux 文件是怎么存储的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E5%BE%85%E5%AD%A6%E4%B9%A0"><span class="toc-number">4.3.</span> <span class="toc-text"> 文件处理命令（待学习）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">4.3.1.</span> <span class="toc-text"> grep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed"><span class="toc-number">4.3.2.</span> <span class="toc-text"> sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk"><span class="toc-number">4.3.3.</span> <span class="toc-text"> awk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%B6%E9%97%B4"><span class="toc-number">4.4.</span> <span class="toc-text"> 文件的三种时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell%E8%84%9A%E6%9C%AC"><span class="toc-number">4.5.</span> <span class="toc-text"> shell 脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.6.</span> <span class="toc-text"> 硬链接和软连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">4.6.1.</span> <span class="toc-text"> 硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.6.2.</span> <span class="toc-text"> 软连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.3.</span> <span class="toc-text"> 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5-2"><span class="toc-number">4.6.3.1.</span> <span class="toc-text"> 硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E8%BF%9E%E6%8E%A5-2"><span class="toc-number">4.6.3.2.</span> <span class="toc-text"> 软连接</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2021/12/25/computer-science/interview/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98/" rel="bookmark" title="后端面试常问问题">后端面试常问问题</a></li><li class="active"><a href="/2021/12/26/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="bookmark" title="后端面试之操作系统">后端面试之操作系统</a></li><li><a href="/2022/01/06/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="bookmark" title="后端面试之数据库">后端面试之数据库</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="张林"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">张林</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">25</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">14</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">13</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW5nbGluMjMz" title="https:&#x2F;&#x2F;github.com&#x2F;zhanglin233"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTMzMDkwMzM3Mg==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;330903372"><i class="ic i-cloud-music"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2021/12/25/computer-science/interview/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%97%AE%E9%A2%98/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/01/06/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/SpringBoot/" title="分类于 SpringBoot">SpringBoot</a>
</div>

    <span><a href="/2021/11/27/computer-science/java/SpringBoot/2021-11-17-springboot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bspringboot/" title="springboot基础篇之快速上手springboot">springboot基础篇之快速上手springboot</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/python/" title="分类于 Python">Python</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/python/spider/" title="分类于 爬虫">爬虫</a>
</div>

    <span><a href="/2021/11/27/computer-science/python/spider/2020-11-17-pixiv1/" title="爬取p站(pixiv)的图片（一）">爬取p站(pixiv)的图片（一）</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/front-end/" title="分类于 前端">前端</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/front-end/React/" title="分类于 React">React</a>
</div>

    <span><a href="/2021/11/27/computer-science/front-end/React/2021-9-16-React%E7%9A%84%E7%BB%84%E4%BB%B6/" title="React的组件">React的组件</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/front-end/" title="分类于 前端">前端</a>
</div>

    <span><a href="/2021/11/27/computer-science/front-end/2021-9-15-ES6%E7%89%B9%E6%80%A7/" title="ES6特性">ES6特性</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/SpringBoot/" title="分类于 SpringBoot">SpringBoot</a>
</div>

    <span><a href="/2021/11/27/computer-science/java/SpringBoot/2021-11-19-SpringBoot%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E7%AF%87%E4%B9%8B%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C/" title="springboot运维实用篇之打包与运行">springboot运维实用篇之打包与运行</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/SpringBoot/" title="分类于 SpringBoot">SpringBoot</a>
</div>

    <span><a href="/2021/11/27/computer-science/java/SpringBoot/2021-11-18-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/" title="springboot基础篇之基础配置">springboot基础篇之基础配置</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a>
</div>

    <span><a href="/2021/12/26/computer-science/interview/%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="后端面试之操作系统">后端面试之操作系统</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/SpringBoot/" title="分类于 SpringBoot">SpringBoot</a>
</div>

    <span><a href="/2021/11/27/computer-science/java/SpringBoot/2021-7-10-java%E4%B9%8Bjunit%E6%B5%8B%E8%AF%95/" title="java之junit测试">java之junit测试</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/" title="分类于 Java">Java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/java/SpringBoot/" title="分类于 SpringBoot">SpringBoot</a>
</div>

    <span><a href="/2021/11/27/computer-science/java/SpringBoot/2021-11-18-SpringBoot%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8A%80%E6%9C%AF/" title="springboot基础篇之整合第三方技术">springboot基础篇之整合第三方技术</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a>
<i class="ic i-angle-right"></i>
<a href="/categories/computer-science/course-1/" title="分类于 智能控制">智能控制</a>
</div>

    <span><a href="/2021/11/28/computer-science/course_1/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%94%AE%E7%9B%98%E5%8F%8A%E5%85%B6%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/" title="键盘及其接口技术">键盘及其接口技术</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">张林 @ zhanglin</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">156k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">2:22</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2021/12/26/computer-science/interview/后端面试之操作系统/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?04b474bb6c6910e6b4240a1f2c3028a7";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</body>
</html>
